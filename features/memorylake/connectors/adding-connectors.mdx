---
title: "Adding New Connectors"
description: "Developer guide for implementing new external service connectors"
---

## Overview

This guide is for developers building custom connectors to integrate additional external services with MemoryLake.

## Prerequisites

- Familiarity with REST APIs
- OAuth 2.0 knowledge (for OAuth-based connectors)
- Access to target service's API documentation
- Development environment set up

## Connector Interface

### Required Methods

All connectors must implement:

```javascript
const ConnectorInterface = {
  // Metadata
  name: 'service-name',
  displayName: 'Service Name',
  icon: 'service-icon',
  
  // Authentication
  async checkStatus(userId) {
    // Return connection status
    return { connected: boolean, error: string };
  },
  
  async authenticate(apiEndpoint) {
    // Initiate OAuth or API key auth
    return { authUrl: string, state: string };
  },
  
  async handleCallback(code, state) {
    // Complete authentication
    return { success: boolean, error: string };
  },
  
  async revoke(userId) {
    // Revoke authorization
    return { success: boolean };
  },
  
  // Resource Management
  async listResources(userId) {
    // List available libraries/folders
    return [{ id: string, name: string, type: string }];
  },
  
  async createMountPoint(userId, resourceId, parentId) {
    // Create mount point in user's drive
    return { success: boolean, itemId: string };
  },
  
  async removeConnection(userId, driveId) {
    // Remove specific mount point
    return { success: boolean };
  },
  
  // Content Access
  async getItem(userId, externalId) {
    // Fetch item metadata
    return { id, name, type, size, modifiedAt };
  },
  
  async listChildren(userId, externalId) {
    // List folder contents
    return [{ id, name, type }];
  },
  
  async downloadFile(userId, externalId) {
    // Get file download URL or stream
    return { url: string } | { stream: ReadableStream };
  }
};
```

## Implementation Steps

<Steps>
<Step title="Register Connector">
Add connector metadata to registry:

```javascript
// connectors/registry.js
export const connectors = {
  'myservice': MyServiceConnector,
  'wps': WPSConnector,
  // ...
};
```
</Step>

<Step title="Implement Authentication">
OAuth 2.0 example:

```javascript
async authenticate(apiEndpoint) {
  const state = generateRandomState();
  const authUrl = `https://service.com/oauth/authorize?`
    + `client_id=${CLIENT_ID}`
    + `&redirect_uri=${REDIRECT_URI}`
    + `&scope=read_files`
    + `&state=${state}`;
  
  // Store state for verification
  await storeState(state);
  
  return { authUrl, state };
}

async handleCallback(code, state) {
  // Verify state
  if (!await verifyState(state)) {
    return { success: false, error: 'Invalid state' };
  }
  
  // Exchange code for tokens
  const tokens = await exchangeCodeForTokens(code);
  
  // Store tokens securely
  await storeTokens(userId, tokens);
  
  return { success: true };
}
```
</Step>

<Step title="Implement Resource Discovery">
List available resources:

```javascript
async listResources(userId) {
  const token = await getAccessToken(userId);
  
  const response = await fetch('https://api.service.com/libraries', {
    headers: { Authorization: `Bearer ${token}` }
  });
  
  const libraries = await response.json();
  
  return libraries.map(lib => ({
    id: lib.id,
    name: lib.name,
    type: 'library'
  }));
}
```
</Step>

<Step title="Create Mount Points">
Integrate external content:

```javascript
async createMountPoint(userId, resourceId, parentId) {
  // Fetch resource details
  const resource = await this.getResource(userId, resourceId);
  
  // Create item in user's drive
  const item = await createDriveItem({
    parentId,
    name: resource.name,
    type: 'mount-point',
    connectorType: this.name,
    externalId: resourceId
  });
  
  return { success: true, itemId: item.id };
}
```
</Step>

<Step title="Implement Content Access">
Fetch files and folders:

```javascript
async listChildren(userId, externalId) {
  const token = await getAccessToken(userId);
  
  const response = await fetch(
    `https://api.service.com/folders/${externalId}/children`,
    { headers: { Authorization: `Bearer ${token}` } }
  );
  
  const items = await response.json();
  
  return items.map(item => ({
    id: item.id,
    name: item.name,
    type: item.type, // 'file' or 'folder'
    size: item.size,
    modifiedAt: item.modified
  }));
}
```
</Step>
</Steps>

## Frontend Components

Create UI for your connector:

```jsx
// ConnectorCard.jsx
export function MyServiceConnectorCard({ onConnect }) {
  const { data: status } = useConnectorStatus('myservice');
  
  return (
    <Card>
      <CardHeader>
        <Icon name="myservice" />
        <Title>My Service</Title>
        {status.connected && <Badge>Connected</Badge>}
      </CardHeader>
      <CardBody>
        Connect your My Service account to access documents.
      </CardBody>
      <CardFooter>
        {status.connected ? (
          <Button onClick={onManage}>Manage</Button>
        ) : (
          <Button onClick={onConnect}>Connect</Button>
        )}
      </CardFooter>
    </Card>
  );
}
```

## Testing

Test your connector thoroughly:

```javascript
describe('MyServiceConnector', () => {
  it('should authenticate successfully', async () => {
    const result = await connector.authenticate(API_ENDPOINT);
    expect(result.authUrl).toBeDefined();
    expect(result.state).toBeDefined();
  });
  
  it('should list resources', async () => {
    const resources = await connector.listResources(TEST_USER_ID);
    expect(Array.isArray(resources)).toBe(true);
    expect(resources.length).toBeGreaterThan(0);
  });
  
  it('should create mount point', async () => {
    const result = await connector.createMountPoint(
      TEST_USER_ID,
      TEST_RESOURCE_ID,
      ROOT_FOLDER_ID
    );
    expect(result.success).toBe(true);
    expect(result.itemId).toBeDefined();
  });
});
```

## Best Practices

- **Error Handling**: Handle API errors gracefully
- **Token Refresh**: Implement automatic token refresh for OAuth
- **Rate Limiting**: Respect service API rate limits
- **Caching**: Cache metadata to reduce API calls
- **Logging**: Log important events for debugging
- **Security**: Never log tokens or sensitive data

## Submission

To add your connector to MemoryLake:
1. Complete implementation and testing
2. Submit pull request with connector code
3. Include documentation and examples
4. Pass code review and security audit

## Next Steps

<CardGroup cols={2}>
<Card title="Connector Framework" icon="diagram-project" href="/features/memorylake/connectors/connector-framework">
Understand the architecture
</Card>

<Card title="WPS Connector" icon="code" href="https://github.com/example/wps-connector">
Reference implementation
</Card>
</CardGroup>
